//! B-Spline Parity Tests: Compare ArKan's compute_basis with SciPy reference values.
//!
//! This test loads reference data generated by `scripts/export_spline_data.py`
//! and compares ArKan's B-spline basis computation against SciPy's implementation.
//!
//! # Test Coverage
//!
//! - Multiple grid sizes (3, 5, 8)
//! - Multiple spline orders (2, 3, 4)
//! - Various grid ranges
//! - Grid points, midpoints, and random interior points
//! - Partition of Unity property verification
//!
//! # Running the tests
//!
//! First generate reference data:
//! ```bash
//! python scripts/export_spline_data.py
//! ```
//!
//! Then run the tests:
//! ```bash
//! cargo test --test spline_parity
//! ```

use arkan::spline::{compute_basis, compute_knots, find_span};
use std::fs;
use std::path::Path;

/// Maximum allowed absolute error for basis function values.
const TOLERANCE: f32 = 1e-5;

/// Maximum allowed deviation from partition of unity (sum should be 1.0).
const PARTITION_TOLERANCE: f32 = 1e-5;

/// Path to the reference data file.
const TEST_DATA_PATH: &str = "tests/spline_test_data.json";

/// Parsed test configuration.
#[derive(Debug)]
struct TestConfig {
    grid_size: usize,
    order: usize,
    range: (f32, f32),
}

/// Parsed test case.
#[derive(Debug)]
#[allow(dead_code)]
struct TestCase {
    x: f32,
    span: usize,
    basis: Vec<f32>,
    basis_sum: f32,
    case_type: String,
}

/// Load and parse the JSON test data.
fn load_test_data() -> Option<serde_json::Value> {
    let path = Path::new(TEST_DATA_PATH);
    if !path.exists() {
        eprintln!(
            "WARNING: Test data file not found: {}\n\
             Run 'python scripts/export_spline_data.py' to generate it.\n\
             Skipping spline parity tests.",
            TEST_DATA_PATH
        );
        return None;
    }

    let content = fs::read_to_string(path).ok()?;
    serde_json::from_str(&content).ok()
}

/// Parse a configuration from JSON.
fn parse_config(cfg: &serde_json::Value) -> Option<TestConfig> {
    let config = cfg.get("config")?;
    Some(TestConfig {
        grid_size: config.get("grid_size")?.as_u64()? as usize,
        order: config.get("order")?.as_u64()? as usize,
        range: {
            let r = config.get("range")?.as_array()?;
            (r[0].as_f64()? as f32, r[1].as_f64()? as f32)
        },
    })
}

/// Parse a test case from JSON.
fn parse_test_case(tc: &serde_json::Value) -> Option<TestCase> {
    Some(TestCase {
        x: tc.get("x")?.as_f64()? as f32,
        span: tc.get("span")?.as_u64()? as usize,
        basis: tc
            .get("basis")?
            .as_array()?
            .iter()
            .filter_map(|v| v.as_f64().map(|f| f as f32))
            .collect(),
        basis_sum: tc.get("basis_sum")?.as_f64()? as f32,
        case_type: tc
            .get("type")
            .and_then(|v| v.as_str())
            .unwrap_or("unknown")
            .to_string(),
    })
}

/// Main parity test against SciPy reference data.
#[test]
fn test_spline_parity_with_scipy() {
    let data = match load_test_data() {
        Some(d) => d,
        None => {
            println!("Skipping test: no reference data available");
            return;
        }
    };

    let configurations = match data.get("configurations").and_then(|c| c.as_array()) {
        Some(c) => c,
        None => {
            panic!("Invalid test data format: missing 'configurations' array");
        }
    };

    let mut total_tests = 0;
    let mut passed_tests = 0;
    let mut max_error: f32 = 0.0;

    for cfg_json in configurations {
        let config = match parse_config(cfg_json) {
            Some(c) => c,
            None => continue,
        };

        let test_cases = match cfg_json.get("test_cases").and_then(|t| t.as_array()) {
            Some(t) => t,
            None => continue,
        };

        println!(
            "\n=== Testing grid={}, order={}, range={:?} ===",
            config.grid_size, config.order, config.range
        );

        // Generate knots using ArKan's function
        let knots = compute_knots(config.grid_size, config.order, config.range);

        // Compare knots with reference (if provided)
        if let Some(ref_knots) = cfg_json.get("knots").and_then(|k| k.as_array()) {
            let ref_knots: Vec<f32> = ref_knots
                .iter()
                .filter_map(|v| v.as_f64().map(|f| f as f32))
                .collect();

            if knots.len() == ref_knots.len() {
                let knot_error: f32 = knots
                    .iter()
                    .zip(ref_knots.iter())
                    .map(|(a, b)| (a - b).abs())
                    .fold(0.0, f32::max);

                if knot_error > TOLERANCE {
                    println!(
                        "WARNING: Knot vectors differ by {:.6} (tolerance: {:.6})",
                        knot_error, TOLERANCE
                    );
                }
            }
        }

        for tc_json in test_cases {
            let tc = match parse_test_case(tc_json) {
                Some(t) => t,
                None => continue,
            };

            total_tests += 1;

            // Compute basis using ArKan
            let span = find_span(tc.x, &knots, config.order, config.grid_size);
            let mut arkan_basis = vec![0.0f32; config.order + 1];
            compute_basis(tc.x, span, &knots, config.order, &mut arkan_basis);

            // Compare span
            if span != tc.span {
                println!(
                    "  FAIL x={:.6} ({}): span mismatch: arkan={}, scipy={}",
                    tc.x, tc.case_type, span, tc.span
                );
                // Continue with ArKan's span for basis comparison
            }

            // Compare basis values
            let basis_error: f32 = arkan_basis
                .iter()
                .zip(tc.basis.iter())
                .map(|(a, b)| (a - b).abs())
                .fold(0.0, f32::max);

            max_error = max_error.max(basis_error);

            // Check partition of unity
            let arkan_sum: f32 = arkan_basis.iter().sum();
            let partition_error = (arkan_sum - 1.0).abs();

            let basis_ok = basis_error < TOLERANCE;
            let partition_ok = partition_error < PARTITION_TOLERANCE;

            if basis_ok && partition_ok {
                passed_tests += 1;
            } else {
                println!(
                    "  FAIL x={:.6} ({}): basis_err={:.8}, partition_err={:.8}",
                    tc.x, tc.case_type, basis_error, partition_error
                );
                println!("    ArKan: {:?}", arkan_basis);
                println!("    SciPy: {:?}", tc.basis);
            }
        }
    }

    println!(
        "\n=== Summary: {}/{} tests passed, max_error={:.8} ===",
        passed_tests, total_tests, max_error
    );

    assert_eq!(
        passed_tests, total_tests,
        "Spline parity tests failed: {}/{} passed (max error: {:.8})",
        passed_tests, total_tests, max_error
    );
}

/// Test partition of unity property without reference data.
#[test]
fn test_partition_of_unity() {
    let configs = [
        (5, 3, (-1.0f32, 1.0f32)),
        (8, 3, (-2.0, 2.0)),
        (4, 2, (0.0, 1.0)),
        (6, 4, (-1.0, 1.0)),
    ];

    for (grid_size, order, range) in configs {
        let knots = compute_knots(grid_size, order, range);

        // Test many x values
        let n_tests = 100;
        let (t_min, t_max) = range;

        for i in 0..n_tests {
            let t = i as f32 / (n_tests - 1) as f32;
            let x = t_min + t * (t_max - t_min) * 0.9999; // Avoid exact boundary

            let span = find_span(x, &knots, order, grid_size);
            let mut basis = vec![0.0f32; order + 1];
            compute_basis(x, span, &knots, order, &mut basis);

            let sum: f32 = basis.iter().sum();
            assert!(
                (sum - 1.0).abs() < PARTITION_TOLERANCE,
                "Partition of unity violated at x={}: sum={} (grid={}, order={})",
                x,
                sum,
                grid_size,
                order
            );
        }
    }
}

/// Test that basis functions are non-negative.
#[test]
fn test_basis_non_negative() {
    let configs = [
        (5, 3, (-1.0f32, 1.0f32)),
        (8, 3, (-2.0, 2.0)),
        (4, 2, (0.0, 1.0)),
    ];

    for (grid_size, order, range) in configs {
        let knots = compute_knots(grid_size, order, range);

        let n_tests = 100;
        let (t_min, t_max) = range;

        for i in 0..n_tests {
            let t = i as f32 / (n_tests - 1) as f32;
            let x = t_min + t * (t_max - t_min) * 0.9999;

            let span = find_span(x, &knots, order, grid_size);
            let mut basis = vec![0.0f32; order + 1];
            compute_basis(x, span, &knots, order, &mut basis);

            for (j, &b) in basis.iter().enumerate() {
                assert!(
                    b >= -1e-7,
                    "Negative basis value at x={}: basis[{}]={} (grid={}, order={})",
                    x,
                    j,
                    b,
                    grid_size,
                    order
                );
            }
        }
    }
}

/// Test knot vector generation matches expected formula.
#[test]
fn test_knot_generation() {
    let grid_size = 5;
    let order = 3;
    let range = (-1.0f32, 1.0f32);

    let knots = compute_knots(grid_size, order, range);

    // Expected: n_knots = grid_size + 2*order + 1 = 5 + 6 + 1 = 12
    assert_eq!(knots.len(), grid_size + 2 * order + 1);

    // h = (1.0 - (-1.0)) / 5 = 0.4
    let h = (range.1 - range.0) / grid_size as f32;
    assert!((h - 0.4).abs() < 1e-6);

    // knots[i] = t_min + (i - order) * h
    for i in 0..knots.len() {
        let expected = range.0 + (i as f32 - order as f32) * h;
        assert!(
            (knots[i] - expected).abs() < 1e-6,
            "Knot {} mismatch: got {}, expected {}",
            i,
            knots[i],
            expected
        );
    }
}

/// Test find_span at boundary conditions.
#[test]
fn test_find_span_boundaries() {
    let grid_size = 5;
    let order = 3;
    let range = (-1.0f32, 1.0f32);
    let knots = compute_knots(grid_size, order, range);

    // At left boundary
    let span_left = find_span(-1.0, &knots, order, grid_size);
    assert_eq!(span_left, order, "Span at left boundary should be order");

    // At right boundary (clamped)
    let span_right = find_span(1.0, &knots, order, grid_size);
    assert_eq!(
        span_right,
        order + grid_size - 1,
        "Span at right boundary should be order + grid_size - 1"
    );

    // Beyond boundaries (should be clamped)
    let span_below = find_span(-2.0, &knots, order, grid_size);
    assert_eq!(
        span_below, order,
        "Span below range should be clamped to order"
    );

    let span_above = find_span(2.0, &knots, order, grid_size);
    assert_eq!(
        span_above,
        order + grid_size - 1,
        "Span above range should be clamped"
    );
}
